name: Deploy to Linode

permissions:
  contents: read

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
  push:
    branches:
      - main
    paths-ignore:
      - "**.md"
      - "docs/**"
      - ".github/**"
      - "!.github/workflows/deploy-linode.yml"
  workflow_run:
    workflows: ["Release"]
    types:
      - completed
    branches:
      - main

jobs:
  deploy:
    name: Deploy to Linode Server
    runs-on: ubuntu-latest
    # Skip deployment if triggered by semantic-release commit (contains [skip ci])
    # Always deploy when triggered by workflow_run (after release completes)
    # Deploy on push to main unless commit contains [skip ci]
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.event.head_commit.message != null && !contains(github.event.head_commit.message, '[skip ci]')) ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    environment: ${{ github.event.inputs.environment || 'production' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LINODE_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.LINODE_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Linode
        env:
          LINODE_HOST: ${{ secrets.LINODE_HOST }}
          LINODE_USER: ${{ secrets.LINODE_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH || '/opt/nightscout-backup-site' }}

          # NextAuth and Discord secrets - passed directly from GitHub secrets
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_CLIENT_SECRET: ${{ secrets.DISCORD_CLIENT_SECRET }}
          ALLOWED_DISCORD_USER_ID: ${{ secrets.ALLOWED_DISCORD_USER_ID }}

          # AWS S3 secrets - passed directly from GitHub secrets
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

          # Python Backup API authentication
          PYTHON_BACKUP_API_KEY: ${{ secrets.PYTHON_BACKUP_API_KEY }}
        run: |
          ssh ${LINODE_USER}@${LINODE_HOST} "DEPLOY_PATH='${DEPLOY_PATH}' NEXTAUTH_SECRET='${NEXTAUTH_SECRET}' NEXTAUTH_URL='${NEXTAUTH_URL}' DISCORD_CLIENT_ID='${DISCORD_CLIENT_ID}' DISCORD_CLIENT_SECRET='${DISCORD_CLIENT_SECRET}' ALLOWED_DISCORD_USER_ID='${ALLOWED_DISCORD_USER_ID}' AWS_ACCESS_KEY_ID='${AWS_ACCESS_KEY_ID}' AWS_SECRET_ACCESS_KEY='${AWS_SECRET_ACCESS_KEY}' PYTHON_BACKUP_API_KEY='${PYTHON_BACKUP_API_KEY}' bash -s" << 'EOF'
          set -e

          echo "üì¶ Starting deployment to ${DEPLOY_PATH}..."

          # Navigate to deployment directory
          cd "${DEPLOY_PATH}"

          # Pull latest changes
          echo "üîÑ Pulling latest changes..."
          git fetch origin
          git checkout main
          git pull origin main

          # üß† Make sure bun is available in PATH
          if [ -d "$HOME/.bun" ]; then
            export BUN_INSTALL="$HOME/.bun"
            export PATH="$BUN_INSTALL/bin:$PATH"
          fi

          # Also check common installation paths
          if ! command -v bun &> /dev/null; then
            if [ -f "/usr/local/bin/bun" ]; then
              export PATH="/usr/local/bin:$PATH"
            elif [ -f "/usr/bin/bun" ]; then
              export PATH="/usr/bin:$PATH"
            fi
          fi

          # üß† Make sure Node & PM2 are available
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"

          # Verify bun is available
          if ! command -v bun &> /dev/null; then
            echo "‚ùå Error: bun is not found in PATH"
            echo "Current PATH: $PATH"
            echo "Checking common locations..."
            ls -la ~/.bun/bin/bun 2>/dev/null || echo "~/.bun/bin/bun not found"
            ls -la /usr/local/bin/bun 2>/dev/null || echo "/usr/local/bin/bun not found"
            ls -la /usr/bin/bun 2>/dev/null || echo "/usr/bin/bun not found"
            exit 1
          fi
          echo "‚úÖ Found bun at: $(which bun)"
          bun --version

          # Install dependencies
          echo "üìö Installing dependencies..."
          bun install --frozen-lockfile

          # Build Next.js application
          echo "üèóÔ∏è  Building Next.js application..."
          bun run build

          # Export environment variables for PM2
          # These will be available to the Next.js application
          # Variables are passed from GitHub Actions secrets via SSH command
          export NEXTAUTH_SECRET="${NEXTAUTH_SECRET}"
          export NEXTAUTH_URL="${NEXTAUTH_URL}"
          export DISCORD_CLIENT_ID="${DISCORD_CLIENT_ID}"
          export DISCORD_CLIENT_SECRET="${DISCORD_CLIENT_SECRET}"
          export ALLOWED_DISCORD_USER_ID="${ALLOWED_DISCORD_USER_ID}"
          export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          export PYTHON_BACKUP_API_KEY="${PYTHON_BACKUP_API_KEY}"

          echo "‚úÖ Environment variables exported for PM2"
          echo "   NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:+[SET]}${NEXTAUTH_SECRET:-[NOT SET]}"
          echo "   NEXTAUTH_URL: ${NEXTAUTH_URL:+[SET]}${NEXTAUTH_URL:-[NOT SET]}"
          echo "   DISCORD_CLIENT_ID: ${DISCORD_CLIENT_ID:+[SET]}${DISCORD_CLIENT_ID:-[NOT SET]}"
          echo "   DISCORD_CLIENT_SECRET: ${DISCORD_CLIENT_SECRET:+[SET]}${DISCORD_CLIENT_SECRET:-[NOT SET]}"
          echo "   ALLOWED_DISCORD_USER_ID: ${ALLOWED_DISCORD_USER_ID:+[SET]}${ALLOWED_DISCORD_USER_ID:-[NOT SET]}"
          echo "   AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID:+[SET]}${AWS_ACCESS_KEY_ID:-[NOT SET]}"
          echo "   AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY:+[SET]}${AWS_SECRET_ACCESS_KEY:-[NOT SET]}"
          echo "   PYTHON_BACKUP_API_KEY: ${PYTHON_BACKUP_API_KEY:+[SET]}${PYTHON_BACKUP_API_KEY:-[NOT SET]}"

          # Verify variables are actually set (non-empty)
          if [ -z "${NEXTAUTH_SECRET}" ]; then
            echo "‚ùå ERROR: NEXTAUTH_SECRET is not set!"
            exit 1
          fi
          if [ -z "${NEXTAUTH_URL}" ]; then
            echo "‚ùå ERROR: NEXTAUTH_URL is not set!"
            exit 1
          fi
          if [ -z "${DISCORD_CLIENT_ID}" ]; then
            echo "‚ùå ERROR: DISCORD_CLIENT_ID is not set!"
            exit 1
          fi
          if [ -z "${DISCORD_CLIENT_SECRET}" ]; then
            echo "‚ùå ERROR: DISCORD_CLIENT_SECRET is not set!"
            exit 1
          fi
          if [ -z "${ALLOWED_DISCORD_USER_ID}" ]; then
            echo "‚ùå ERROR: ALLOWED_DISCORD_USER_ID is not set!"
            exit 1
          fi
          if [ -z "${AWS_ACCESS_KEY_ID}" ]; then
            echo "‚ùå ERROR: AWS_ACCESS_KEY_ID is not set!"
            exit 1
          fi
          if [ -z "${AWS_SECRET_ACCESS_KEY}" ]; then
            echo "‚ùå ERROR: AWS_SECRET_ACCESS_KEY is not set!"
            exit 1
          fi
          if [ -z "${PYTHON_BACKUP_API_KEY}" ]; then
            echo "‚ùå ERROR: PYTHON_BACKUP_API_KEY is not set!"
            exit 1
          fi

          # Restart the service with PM2
          # Delete and restart to ensure environment variables are picked up
          echo "üîÑ Restarting application..."
          if pm2 describe nightscout-backup-site &>/dev/null; then
            # Process exists, delete it first to ensure clean restart with new env vars
            pm2 delete nightscout-backup-site || true
          fi
          # Start with current shell environment variables
          # PM2 will inherit all exported environment variables
          pm2 start ecosystem.prod.config.js

          # Wait for application to start
          echo "‚è≥ Waiting for application to start..."
          sleep 5

          # Verify environment variables are set in PM2 process
          echo "üîç Verifying environment variables in PM2 process..."
          PM2_ENV=$(pm2 env $(pm2 jlist | grep -o '"pm_id":[0-9]*' | head -1 | cut -d: -f2) 2>/dev/null || echo "")
          if [ -n "$PM2_ENV" ]; then
            if echo "$PM2_ENV" | grep -q "NEXTAUTH_SECRET"; then
              echo "‚úÖ NEXTAUTH_SECRET is set in PM2 process"
            else
              echo "‚ö†Ô∏è  NEXTAUTH_SECRET not found in PM2 process environment"
            fi
            if echo "$PM2_ENV" | grep -q "NEXTAUTH_URL"; then
              echo "‚úÖ NEXTAUTH_URL is set in PM2 process"
            else
              echo "‚ö†Ô∏è  NEXTAUTH_URL not found in PM2 process environment"
            fi
            if echo "$PM2_ENV" | grep -q "DISCORD_CLIENT_ID"; then
              echo "‚úÖ DISCORD_CLIENT_ID is set in PM2 process"
            else
              echo "‚ö†Ô∏è  DISCORD_CLIENT_ID not found in PM2 process environment"
            fi
            if echo "$PM2_ENV" | grep -q "AWS_ACCESS_KEY_ID"; then
              echo "‚úÖ AWS_ACCESS_KEY_ID is set in PM2 process"
            else
              echo "‚ö†Ô∏è  AWS_ACCESS_KEY_ID not found in PM2 process environment"
            fi
            if echo "$PM2_ENV" | grep -q "AWS_SECRET_ACCESS_KEY"; then
              echo "‚úÖ AWS_SECRET_ACCESS_KEY is set in PM2 process"
            else
              echo "‚ö†Ô∏è  AWS_SECRET_ACCESS_KEY not found in PM2 process environment"
            fi
            if echo "$PM2_ENV" | grep -q "PYTHON_BACKUP_API_KEY"; then
              echo "‚úÖ PYTHON_BACKUP_API_KEY is set in PM2 process"
            else
              echo "‚ö†Ô∏è  PYTHON_BACKUP_API_KEY not found in PM2 process environment"
            fi
          else
            echo "‚ö†Ô∏è  Could not retrieve PM2 environment (this is okay if process just started)"
          fi

          # Wait a bit more for full startup
          sleep 5

          # Check status
          echo "‚úÖ Checking application status..."
          pm2 status

          # Check site status
          pm2 describe nightscout-backup-site || echo "‚ö†Ô∏è  Site process not found"
          pm2 logs nightscout-backup-site --lines 20 --nostream || true

          # Test Next.js site health endpoint
          echo "üè• Testing Next.js site endpoint..."
          if curl -f -s http://localhost:3000 > /dev/null; then
            echo "‚úÖ Next.js site health check passed"
          else
            echo "‚ö†Ô∏è  Next.js site health check failed (may still be starting)"
          fi

          echo "‚úÖ Deployment complete!"
          EOF

      - name: Verify Deployment
        env:
          LINODE_HOST: ${{ secrets.LINODE_HOST }}
          LINODE_USER: ${{ secrets.LINODE_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH || '/opt/nightscout-backup-site' }}
        run: |
          ssh ${LINODE_USER}@${LINODE_HOST} "DEPLOY_PATH='${DEPLOY_PATH}' bash -s" << 'EOF'
          # üß† Make sure Node & PM2 are available
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"

          cd "${DEPLOY_PATH}"

          # Check if site is online
          if ! pm2 describe nightscout-backup-site &>/dev/null; then
            echo "‚ùå Site process not found"
            exit 1
          fi

          # Check process status (using pm2 jlist for reliable JSON parsing)
          if command -v jq &> /dev/null; then
            PM2_STATUS=$(pm2 jlist | jq -r '.[] | select(.name=="nightscout-backup-site") | .pm2_env.status' || echo "unknown")
          else
            # Fallback: check if process appears in pm2 list
            PM2_STATUS=$(pm2 list | grep -q "nightscout-backup-site.*online" && echo "online" || echo "unknown")
          fi

          if [ "$PM2_STATUS" != "online" ]; then
            echo "‚ùå Site process is not online (status: $PM2_STATUS)"
            pm2 describe nightscout-backup-site
            exit 1
          fi
          echo "‚úÖ Site process is running (status: $PM2_STATUS)"

          # Test Next.js site endpoint
          if curl -f -s http://localhost:3000 > /dev/null; then
            echo "‚úÖ Next.js site is responding"
          else
            echo "‚ùå Next.js site health check failed"
            exit 1
          fi

          echo "‚úÖ Application is running"
          EOF

      - name: Notify on Success
        if: success()
        run: |
          echo "‚úÖ Deployment to ${{ github.event.inputs.environment || 'production' }} successful!"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"

      - name: Notify on Failure
        if: failure()
        run: |
          echo "‚ùå Deployment to ${{ github.event.inputs.environment || 'production' }} failed!"
          echo "Please check the logs above for details."
